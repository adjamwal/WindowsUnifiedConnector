"""
This script is a simulator for a CMID Cloud HTTPS server.
It accepts GET and POST requests. For POST requests, it accepts a JSON request
and also responds with a JSON from cmid_response.json.

Usage:
1) Hostname has to be added to the /etc/hosts file. This step is only needed if
   this server not in local system. For example: simplehttps.com
2) Generate the keys and self-signed certificates.
   The key has been generated by issuing the following command:
   $ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out key.pem

   The certificate is generated using the following command:
   $ openssl req -x509 -key key.pem -out cert.pem -days 365

3) Give the correct path for certificate and file in below code.
4) Run this server as
    python2 https_json.py --serve <hostname> --port 8080 --handle_once <True/False>

    There should be <hostname>.key.pem and <hostname>.cert.pem files in the
    certificates directory.

    usage: https_json.py [-h] [--serve SERVE] [--handle_once {True,False}]
                         [--port PORT]

    optional arguments:
      -h, --help            show this help message and exit
      --serve SERVE         Domain name to serve (default localhost)
      --handle_once {True,False}
                            If true, the request will be handled once and closed
                            (default False)
      --port PORT           Port number to listen on (default 443)

	In case argparse library is not available, you will have to put all the
    three options in config.py as:

	HTTPS_PORT = 8080  # integer
	SERVE = 'localhost'  # string
	HANDLE_ONCE = 'False'  # string

To send a request to the server:
1) Download the certificate by issuing the following command.

    echo quit | openssl s_client -showcerts -servername simplehttps.com -connect simplehttps.com:8080 > /path/to/certificate

2) Use the below curl command to test

    curl --cacert <certificate_path> -d '{"param1": "data","param2": "data2","param3": "data3","param4": "data4"}' -X POST "https://simplehttps.com:8080/"

If for some reason, GET request is required, below is the example usage
curl --cacert <certificate_path> -X GET "https://simplehttps.com:8080/?a=200&b=222"

"""
import sys
import os
import json
import ssl
import SimpleHTTPServer
import SocketServer

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(1, BASE_DIR)

HTTPS_PORT = []
SERVE = []
HANDLE_ONCE = []
HTTPS_DEFAULT_PORT = 443

try:
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--serve', required=False,
                        help='Domain name to serve (default localhost)',
                        default='localhost')
    parser.add_argument('--handle_once', required=False,
                        help='If true, will handle one request and exit (default False)',
                        default='False', choices=['True', 'False'])
    parser.add_argument('--port', required=False,
                        help='Port number to listen on (default '+str(HTTPS_DEFAULT_PORT)+')',
                        default=HTTPS_DEFAULT_PORT, type=int)
    args = parser.parse_args()
    HTTPS_PORT.append(args.port)
    SERVE.append(args.serve)
    HANDLE_ONCE.append(args.handle_once)

except Exception as e:
    print "WARNING: "+str(e)
    import config
    HTTPS_PORT.append(config.HTTPS_PORT)
    SERVE.append(config.SERVE)
    HANDLE_ONCE.append(config.HANDLE_ONCE)


CMID_REQUEST_FILE = os.path.join(BASE_DIR, 'cmid_request.json')
CMID_RESPONSE_FILE = os.path.join(BASE_DIR, 'cmid_response.json')
CERIFICATE_FOLDER = os.path.join(BASE_DIR, 'certificates/')
process_id = os.path.join(BASE_DIR, 'process_id')

CERIFICATE_FILE_PATH = CERIFICATE_FOLDER + SERVE[0] + '.cert.pem'
KEY_FILE_PATH = CERIFICATE_FOLDER + SERVE[0] + '.key.pem'

g_received_shutdown = False

class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def send_GET_response(self, response_message=''):
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain; charset=utf-8')
        response_message = response_message.encode('utf-8')
        self.send_header('Content-Length', len(response_message))
        self.end_headers()
        self.wfile.write(response_message)

    def do_GET(self):
        if self.path == '/shutdown':
            self.send_GET_response('')
            global g_received_shutdown
            g_received_shutdown = True
            return
        message_parts = [
            'CLIENT VALUES:',
            '    client_address={} ({})'.format( self.client_address, self.address_string()),
            '    command={}'.format(self.command),
            '    path={}'.format(self.path),
            '    request_version={}'.format(self.request_version),
            '',
            'SERVER VALUES:',
            '    server_version={}'.format(self.server_version),
            '    sys_version={}'.format(self.sys_version),
            '    protocol_version={}'.format(self.protocol_version),
            '',
            'HEADERS RECEIVED:',
        ]
        for name, value in sorted(self.headers.items()):
            message_parts.append('    {}={}'.format(name, value.rstrip()))
        message_parts.append('')
        message = '\r\n'.join(message_parts)
        self.send_GET_response(response_message=message)

    def send_POST_response(self, response_code=200, response_headers=None, response_message=''):
        self.send_response(response_code)
        self.send_header('Content-Type', 'application/json; charset=utf-8')
        if response_headers:
            for h, v in response_headers:
                self.send_header(h, v)
        response_message = response_message.encode('utf-8')
        self.send_header('Content-Length', len(response_message))
        self.end_headers()
        self.wfile.write(response_message)

    def do_POST(self):
        # Parse the form data posted
        request = self.rfile.read(int(self.headers['Content-Length']))

        print 'Request headers:',
        for name, value in sorted(self.headers.items()):
            print '{}={}'.format(name, value.rstrip()),
        print
        print 'Request:', request
        # Writing the request to a request file
        with open(CMID_REQUEST_FILE, 'w') as f:
            f.write(request)

        # Trying to fetch the response from the response file.
        # Respond with a hardcoded response if file is empty or not present
        try:
            with open(CMID_RESPONSE_FILE, 'r') as f:
                cmid_response = f.read()
            if cmid_response == '':
                raise IOError
        except IOError:
            if self.path == '/identify':
                cmid_response = '{"ucid":"programmed-default-ucid", "ucid_token":"programmed-default-token", "instance_key":"programmed-default-instance","urls": {"catalog":"localhost/catalog", "checkin":"localhost/checkin", "event":"localhost/event"} }'
            else:
                cmid_response = '{"event_count": 1}'

        headers=[]
        # based on the response content, decide the error code.
        cmid_response_json = json.loads(cmid_response)
        if cmid_response_json.has_key("ucid") and self.path == '/identify':
            response_code = 200
        elif cmid_response_json.has_key("event_count") and self.path == '/event/1':
            response_code = 200
        # special error code 9999 to trigger "Retry-After" response.
        elif cmid_response_json.has_key("code") and cmid_response_json['code'] == 9999:
            response_code = 429
            headers.append(('Retry-After', '7')) # in seconds
        else:
            response_code = 401

        self.send_POST_response(response_code=response_code, response_headers=headers, response_message=cmid_response)


def launch_https_server():
    with open(process_id, 'w') as f:
        f.write(str(os.getpid()))
    httpd = SocketServer.TCPServer(('127.0.0.1', HTTPS_PORT[0]), Handler)
    httpd.socket = ssl.wrap_socket(
        httpd.socket, certfile=CERIFICATE_FILE_PATH, keyfile=KEY_FILE_PATH, server_side=True)

    if HANDLE_ONCE[0] == 'True':
        httpd.handle_request()
    else:
        global g_received_shutdown
        while not g_received_shutdown:
            httpd.handle_request()
        httpd.server_close()

launch_https_server()
