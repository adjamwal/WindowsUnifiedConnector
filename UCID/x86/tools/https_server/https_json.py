'''
This is a very simple script to create a HTTPS server
that can accept GET and POST requests. With POST request,
it accepts JSON as the request and also responds with a presupplied JSON
'''

'''
Usage :
1) Hostname has to be added to the /etc/hosts file only if this server not in local system.
    (Hostname in this case - simplehttps.com)
2) Generate the keys and self-signed certificates.
    (The key has been generated by issuing the following command.
    openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out key.pem

    The certificate is generated using the following command
    openssl req -x509 -key key.pem -out cert.pem -days 365)

3) Give the correct path for certificate and file in below code.
4) Run this server as
    python2 https_json.py --serve <hostname> --handle_once <True/False>

    <hostname> is one of the hostname in the domain_dict below.


    usage: https_json.py [-h] [--serve SERVE] [--handle_once {True,False}]
                         [--port PORT]

    optional arguments:
      -h, --help            show this help message and exit
      --serve SERVE         Domain name to serve (default localhost)
      --handle_once {True,False}
                            If true, the request will be handled once and closed
                            (default False)
      --port PORT           Port number to listen on (default 8080)

	Incase argparse library is not available, you will have to put all the three options in config.py as
	
	HTTPS_PORT = 8080  # integer
	SERVE = 'localhost'  # string
	HANDLE_ONCE = 'False'  # string



To access the server.
1) Download the certificate by issuing the following command.

    echo quit | openssl s_client -showcerts -servername simplehttps.com -connect simplehttps.com:8080 > /path/to/certificate

2) Use the below curl command to test

    curl --cacert <certificate_path> -d '{"param1": "data","param2": "data2","param3": "data3","param4": "data4"}' -X POST "https://simplehttps.com:8080/"

If for some reason, GET request is required, below is the example usage
curl --cacert <certificate_path> -X GET "https://simplehttps.com:8080/?a=200&b=222"

'''
import sys
import os

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(1, BASE_DIR)

import json
import ssl
import SimpleHTTPServer
import SocketServer

HTTPS_PORT = []
SERVE = []
HANDLE_ONCE = []
HTTPS_DEFAULT_PORT = 443

try:
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--serve', required=False,
                        help='Domain name to serve (default localhost)', default='localhost')
    parser.add_argument('--handle_once', required=False,
                        help='If true, the request will be handled once and closed (default False)', default='False', choices=['True', 'False'])
    parser.add_argument('--port', required=False,
                        help='Port number to listen on (default 8080)', default=HTTPS_DEFAULT_PORT, type=int)
    args = parser.parse_args()
    HTTPS_PORT.append(args.port)
    SERVE.append(args.serve)
    HANDLE_ONCE.append(args.handle_once)


except:
    print "Except block"
    import config
    HTTPS_PORT.append(config.HTTPS_PORT)
    SERVE.append(config.SERVE)
    HANDLE_ONCE.append(config.HANDLE_ONCE)


UCID_REQUEST_FILE = os.path.join(BASE_DIR, 'data/ucid_request.json')
UCID_RESPONSE_FILE = os.path.join(BASE_DIR, 'data/ucid_response.json')
CERIFICATE_FOLDER = os.path.join(BASE_DIR, 'certificates/')
process_id = os.path.join(BASE_DIR, 'process_id')


domain_dict = {

    # Put the correct path to the certificate and the keys
    'localhost': ['localhost.cert.pem', 'localhost.key.pem'],
}

CERIFICATE_FILE_PATH = CERIFICATE_FOLDER + domain_dict[SERVE[0]][0]
KEY_FILE_PATH = CERIFICATE_FOLDER + domain_dict[SERVE[0]][1]


class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def do_GET(self):

        message_parts = [
            'CLIENT VALUES:',
            'client_address={} ({})'.format(
                self.client_address,
                self.address_string()),
            'command={}'.format(self.command),
            'path={}'.format(self.path),
            'request_version={}'.format(self.request_version),
            '',
            'SERVER VALUES:',
            'server_version={}'.format(self.server_version),
            'sys_version={}'.format(self.sys_version),
            'protocol_version={}'.format(self.protocol_version),
            '',
            'HEADERS RECEIVED:',
        ]
        for name, value in sorted(self.headers.items()):
            message_parts.append(
                '{}={}'.format(name, value.rstrip())
            )
        message_parts.append('')
        message = '\r\n'.join(message_parts)
        self.send_response(200)
        self.send_header('Content-Type',
                         'text/plain; charset=utf-8')
        self.end_headers()
        self.wfile.write(message.encode('utf-8'))
        if self.path == '/shutdown':
            os._exit(0)

    def do_POST(self):
        # Parse the form data posted
        request = self.rfile.read(int(self.headers['Content-Length']))

        print('Request : \n', request)
        for name, value in sorted(self.headers.items()):
            print('%s=%s' % (name, value.rstrip()))
        # Writing the request to a request file
        open(UCID_REQUEST_FILE, 'w').write(request)

        # Trying to fetch the response from the response file.
        # Respond with a hardcoded response if file is empty or not present
        try:
            ucid_response = open(UCID_RESPONSE_FILE, 'r').read()
            if ucid_response == '':
                raise IOError
        except IOError:
            ucid_response = '{ "ucid": "some-ucid", "token": "some-token" }'

        # based on the reponse content, decide the error code.
        ucid_response_json = json.loads(ucid_response)
        if ucid_response_json.has_key("ucid"):
            response_code = 200
        # special error_code 9999 to trigger "Retry-After" response.
        elif ucid_response_json.has_key("error_code") and ucid_response_json['error_code'] == 9999:
            response_code = 429
        else :
            response_code = 401
        self.send_response(response_code)

        self.send_header('Content-Type',
                         'application/json; charset=utf-8')
        if response_code == 429: #Set above incase of "Retry-After"
            self.send_header('Retry-After',
                                '7') # 7 second retry
            print('Retry-After set to 7 seconds : \n')
        self.end_headers()

        self.wfile.write(ucid_response)


def launch_https_server():
    f = open(process_id, 'w')
    f.write(str(os.getpid()))
    f.close()
    httpd = SocketServer.TCPServer(('127.0.0.1', HTTPS_PORT[0]), Handler)
    httpd.socket = ssl.wrap_socket(
        httpd.socket, certfile=CERIFICATE_FILE_PATH, keyfile=KEY_FILE_PATH, server_side=True)

    if HANDLE_ONCE[0] == 'True':
        httpd.handle_request()
    else:
        httpd.serve_forever()

launch_https_server()
